\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}

\usepackage[normalem]{ulem}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = black, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor    = blue  %Colour of citations
}

\usepackage{color}
\usepackage{colortbl}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{gray}{rgb}{0.7,0.7,0.7}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\theoremstyle{definition}
\newtheorem{problem}{Problem}
\newcommand{\E}{\mathbb E}
\newcommand{\R}{\mathbb R}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\newcommand{\trans}[1]{{#1}^{T}}
\newcommand{\loss}{\ell}
\newcommand{\w}{\mathbf w}
\newcommand{\x}{\mathbf x}
\newcommand{\y}{\mathbf y}
\newcommand{\ltwo}[1]{\lVert {#1} \rVert}

\newcommand{\ignore}[1]{}

\usepackage{listings}

% Default fixed font does not support bold face
\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{12} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{12}  % for normal

% Python style for highlighting
\newcommand\pythonstyle{\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
stepnumber=1,
numbers=left
}}

\lstnewenvironment{python}[1][]
{
    \pythonstyle
    \lstset{#1}
}
{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{center}
    {
\Large
CSCI046 Lab: Scope and Memory Management
}
\end{center}

%\vspace{0.25in}
%\noindent
%Name: 
%
%\noindent
%\rule{\textwidth}{0.1pt}
%\vspace{0.15in}

\section{Instructions}
\noindent
For each problem below, complete the following steps:
\begin{enumerate}
    \item
        Guess the output of the program.
    \item
        Use vim to enter the program into the lambda server, and run the program.
        You should use the same file for each problem.
    \item
        If the results of steps 1 and 2 are different, figure out why.
        You may find the website \url{https://pythontutor.com} helpful.
\end{enumerate}
These problems are intentionally misleading,
so don't just assume you know what the code will do.
You will need to understand all of the concepts described in this document in order to successfully complete future programming homeworks, and your final exam will contain at least one problem similar to these.

\section{Local and Global Variable Scope}
\noindent
By default, all variables are \textbf{global} and accessible anywhere inside or outside a function.
A variable becomes \textbf{local} if it is defined within a function and the \texttt{global} keyword is not used.

\begin{problem}
    ~
\begin{python}
xs = [1,2,3]
def foo():
    print('xs=',xs)
foo()
\end{python}
\end{problem}
\vspace{0.85in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    xs = 'a'
    print('xs=',xs)
foo()
\end{python}
\end{problem}
\vspace{1in}

\newpage
\noindent
\textbf{Note:}
Modifying a global variable does not make the variable local.
The only way to make a variable local is if it appears to the left of an equals sign \emph{by itself}
(i.e.\ appearing to the left of an equal sign does not matter if there is a slice).
Calling a function that modifies a variable does not make a variable local.

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    xs = 'a'
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    xs[-1] = 'a'
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1.5in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    xs.pop()
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1.5in}

\newpage

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    xs.append('a')
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1.5in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    xs.pop()
def bar():
    global xs
    xs = [4,5,6]
    xs.append('a')
foo()
bar()
bar()
foo()
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1.5in}


\newpage
\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    xs = [4,5,6]
    xs.append('a')
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    xs = [4,5,6]
    xs.append('a')
    print('xs=',xs)
foo()
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo():
    global xs
    xs = [4,5,6]
    xs.append('a')
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\newpage
\begin{problem}
~~~
%\sout{~~~}
%The following code causes an error in python.
%Enter the code into the python interpreter;
%make sure you understand the error message and why the error is occurring.
%You do not have to write anything for this problem.
\begin{python}
xs = [1,2,3]
def foo():
    xs.append('a')
    xs = [4,5,6]
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
~~~
%\textbf{Ensure that you understand why this code is okay,
%but the previous problem causes an error.}
\begin{python}
xs = [1,2,3]
def foo():
    global xs
    xs.append('a')
    xs = [4,5,6]
foo()
print('xs=',xs)
\end{python}
\end{problem}
\vspace{1in}

\newpage
\noindent
\textbf{Note:}
It is fairly common to define functions within functions in python.
These are called \emph{local functions} because they are only accessible from within the outer function (just like local variables).
These problems are designed to give you practice understanding how scope works in these local functions.

\begin{problem}
~~~
\begin{python}
x = 'a'
xs = [1,2,3]
def foo():
    x = 'b'
    xs = [1,2,3]
    def bar():
        x = 'c'
        xs[0] = 'd'
    bar()
    print('x=',x)
    print('xs=',xs)
foo()
\end{python}
\end{problem}
\vspace{0.75in}

\begin{problem}
~~~
\begin{python}
x = 'a'
xs = [1,2,3]
def foo():
    global xs
    x = 'b'
    xs = [1,2,3]
    def bar():
        global x
        x = 'c'
        xs[0] = 'd'
    bar()
    print('x=',x)
    print('xs=',xs)
foo()
\end{python}
\end{problem}

\newpage
\section{Memory Management}
\noindent
\textbf{Note:}
Assignment makes two variable names refer to the same object.
Changing the contents of one variable actually changes the contents of the object,
and therefore changes the contents of both variables.
In order to create new, distinct, objects, you must copy the variable.

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
ys = xs
ys.append('a')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
~~~
\begin{python}
import copy
xs = [1,2,3]
ys = copy.copy(xs)
ys.append('a')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage
\noindent
\textbf{Note:}
When lists contain non-container objects like integers, \texttt{copy} and \texttt{deepcopy} behave exactly the same way.
When lists contain containers, then copy and deep copy behave differently.

\begin{problem}
~~~
\begin{python}
import copy
xs = [[1,2,3],[4,5,6]]
ys = copy.copy(xs)
ys[0][0] = 'a'
xs[1][1] = 'b'
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Use the same code as above, but change \texttt{copy.copy} to \texttt{copy.deepcopy}.

\vspace{0.15in}
\noindent
HINT: Use vim's find/replace functionality with the \texttt{:s} command.

\noindent
See \url{https://vim.fandom.com/wiki/Search_and_replace} for details.
%~~~
%\begin{python}
%import copy
%xs = [[1,2,3],[4,5,6]]
%ys = copy.deepcopy(xs)
%ys[0][0] = 'a'
%xs[1][1] = 'b'
%print('xs=',xs)
%print('ys=',ys)
%\end{python}
\end{problem}
\vspace{2in}

\newpage
\begin{problem}
~~~
\begin{python}
import copy
xs = [[1,2,3],[4,5,6]]
ys = copy.copy(xs)
ys.append('a')
ys[0].append('b')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
Use the same code as above, but change \texttt{copy.copy} to \texttt{copy.deepcopy}.

\vspace{0.15in}
\noindent
HINT: Use vim's find/replace functionality with the \texttt{:s} command.

\noindent
See \url{https://vim.fandom.com/wiki/Search_and_replace} for details.
%\begin{python}
%import copy
%xs = [[1,2,3],[4,5,6]]
%ys = copy.deepcopy(xs)
%ys.append('a')
%ys[0].append = 'b'
%print('xs=',xs)
%print('ys=',ys)
%\end{python}
\end{problem}
\vspace{2in}
%\newpage
%\begin{problem}
%~~~
%\begin{python}
%import copy
%xs = [1,2,3]
%ys = copy.copy(xs)
%ys[0] = 'a'
%ys = xs
%print('xs=',xs)
%print('ys=',ys)
%\end{python}
%\end{problem}
%\vspace{2in}
%
%\begin{problem}
%~~~
%\begin{python}
%xs = [1,2,3]
%ys = copy.copy(xs)
%ys.append(4)
%print('xs=',xs)
%print('ys=',ys)
%\end{python}
%\end{problem}

\newpage
\noindent
\textbf{Note:}
Variables that are parameters to a function are always local variables.
But, if a default parameter is used, these objects are only created once and the same copy is used in all subsequent calls that require a default parameter.

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
def foo(xs=[]):
    print('xs=',xs)
    xs.append(len(xs)+1)
foo()
foo()
foo()
foo([])
foo()
foo()
\end{python}
\end{problem}
\vspace{1.5in}

\noindent
\textbf{Note:}
Unfortunately, default parameters behave differently for container objects and non-container objects.

\begin{problem}
~~~
\begin{python}
n = 7
def foo(n=0):
    print('n=',n)
    n+=1
foo()
foo()
foo()
foo(1)
foo()
foo()
\end{python}
\end{problem}
\vspace{2in}

\newpage
\noindent
\textbf{Note:}
The following problems illustrate different ways that you might try to reverse a list in python.
At first glance, they all look the same.
Due to memory management issues, however, they are not all correct.
Understanding memory management is important when tracking down these subtle bugs,
and you are guaranteed to run into these situations in later assignments in this course.

\vspace{0.15in}
\noindent
\textbf{Note:}
Writing a function that reverses a list is one of the classic interview questions for python programming jobs.
Interviewers frequently say that they are shocked by the number of interviewees who fail these questions because they don't understand memory management.
Pay special attention to these problems so that you do not fail future interview questions and can get a great job.

\begin{problem}
~~~
\begin{python}
def reverse_list(xs):
    ys = xs
    for i in range(len(ys)):
        ys[i] = xs[-i-1]
    return ys
xs = [1,2,3]
ys = reverse_list(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{0.75in}

\begin{problem}
~~~
\begin{python}
import copy
def reverse_list(xs):
    ys = copy.copy(xs)
    for i in range(len(ys)):
        xs[i] = ys[-i-1]
    return ys
xs = [1,2,3]
ys = reverse_list(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage
\begin{problem}
~~~
\begin{python}
import copy
def reverse_list(xs):
    ys = copy.copy(xs)
    for i in range(len(ys)):
        ys[i] = xs[-i-1]
    return ys
xs = [1,2,3]
ys = reverse_list(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
~~~
\begin{python}
def reverse_list():
    ys = xs
    for i in range(len(ys)):
        ys[i] = xs[-i-1]
    return ys
xs = [1,2,3]
ys = reverse_list()
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}


\newpage
\noindent
\textbf{Note:}
Because reversing a list is a common task,
python provides two inbuilt methods to accomplish it.
The \texttt{reverse} function does not create a copy of a list, but instead changes the list in place.
The \texttt{reversed} function makes a copy of the list, reverses the copy, and leaves the original list unmodified.
Both functions are widely used in python code.

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
ys = xs.reverse()
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
ys = list(reversed(xs))
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}

\newpage
\noindent
\textbf{Note:}
Sorting is another common task, and python contains two functions for sorting lists: \texttt{sort} and \texttt{sorted}.
It is a python convention that any function in the past tense returns a copy of the list without modifying the list, 
and any function written in the imperative modifies the list in place.

\begin{problem}
~~~
\begin{python}
xs = [2,3,1]
ys = xs.sort()
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
~~~
\begin{python}
xs = [2,3,1]
ys = list(sorted(xs))
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}

\newpage
\noindent
\textbf{Note:}
Internally, the \texttt{reversed} and \texttt{sorted} functions perform shallow copies instead of deep copies.

\begin{problem}
~~~
\begin{python}
xs = [[1,2,3],[4,5,6]]
ys = list(reversed(xs))
ys.append('a')
ys[0].append('b')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
~~~
\begin{python}
import copy
xs = [[1,2,3],[4,5,6]]
ys = list(reversed(copy.deepcopy(xs)))
ys.append('a')
ys[0].append('b')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}

\ignore{
\newpage
\noindent
\textbf{Note:}
The next set of problems use recursion.
Remember that everytime a function is called, a new frame is created that has new local variables.

%\begin{problem}
%~~~
%\begin{python}
%xs = []
%def foo(xs,i):
%if i>3:
    %return
%xs.append(i)
%foo(xs,i+1)
%print('i=',i,'xs=',xs)
%foo(xs,0)

%\end{python}
%\end{problem}
%\vspace{2in}

%\begin{problem}
%~~~
%\begin{python}
%xs = []
%def foo(i):
    %print('i=',i,'xs=',xs)
    %if i>3:
        %return
    %xs.append(i)
    %foo(i+1)
%foo(0)
%\end{python}
%\end{problem}
%\vspace{2in}

\begin{problem}
~~~
\begin{python}
xs = []
def foo(i):
    print('i=',i,'xs=',xs)
    if i>3:
        return
    xs.append(i)
    foo(i+1)
foo(0)
\end{python}
\end{problem}
\vspace{2in}


\begin{problem}
~~~
\begin{python}
x = 0
def foo(y):
    global x
    x += 1
    print('x=',x,'y=',y)
    if y==0:
        return
    foo(y-1)
    print('x=',x,'y=',y)
foo(3)
\end{python}
\end{problem}

\newpage
\noindent
\textbf{Note:}
These final problems combine recusion, memory management, and scope issues on the practical problem of reversing a list.
Notice that you must pay close attention to these issues or you can accidentally corrupt your input data.

\begin{problem}
~~~
\begin{python}
def reverse_recursive(xs):
    def go(xs,ys):
        if len(xs)==0:
            return ys
        ys.append(xs.pop())
        return go(xs,ys)
    return go(xs,[])

xs = [1,2,3]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{1in}

\begin{problem}
~~~
\begin{python}
def reverse_recursive(xs):
    import copy
    xs = copy.copy(xs)
    def go(xs,ys):
        if len(xs)==0:
            return ys
        ys.append(xs.pop())
        return go(xs,ys)
    return go(xs,[])

xs = [1,2,3]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage
\noindent
\textbf{Note:}
Combining recursion with default parameters is potentially dangerous.

\begin{problem}
~~~
\begin{python}
def reverse_recursive(xs,ys=[]):
    import copy
    xs = copy.copy(xs)
    if len(xs)==0:
        return ys
    ys.append(xs.pop())
    return reverse_recursive(xs,ys)

xs = [1,2,3]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)

xs = [4,5,6]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage

\begin{problem}
~~~
\begin{python}
def reverse_recursive(xs,ys=None):
    import copy
    xs = copy.copy(xs)
    if ys is None:
        ys = []
    if len(xs)==0:
        return ys
    ys.append(xs.pop())
    return reverse_recursive(xs,ys)

xs = [1,2,3]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)

xs = [4,5,6]
ys = reverse_recursive(xs)
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newpage
\noindent
\textbf{Note:}
There are many ways in python to make shallow copies of containers besides using \texttt{copy.copy}.
You will see people use all of them in real python code,
although the most ``pythonic'' way to do it is to use the \texttt{copy.copy} function since it is the most readable.
The only way to make deep copies is with the \texttt{copy.deepcopy} function.

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
ys = xs[:]
ys.append('a')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3]
ys = list(xs)
ys.append('a')
print('xs=',xs)
print('ys=',ys)
\end{python}
\end{problem}
\vspace{2in}

\newpage
\section{Memory and Loops}
\noindent
Modifying a container that you are looping over is dangerous;
strange behavior can occur depending on how you modify the container.
We call these errors ``silent errors'' because they do not generate error messages.

Silent errors are one of the most insidious sources of programming bugs because they are so difficult to detect.
Unfortunately, python is notorious for these silent errors due to its weak type system.
Other languages (like C++, Java, and Haskell) have much stronger type systems that prevent certain classes of silent errors from ever occuring.

If you want to modify a container inside a for loop,
you should probably instead loop over a copy of the container to prevent unintended behavior.

\begin{problem}
~~~
\begin{python}
xs = [1,2,3,4,5]
for x in xs:
    print('x=',x)
    xs.pop()
\end{python}
\end{problem}
\vspace{2in}

\begin{problem}
~~~
\begin{python}
xs = [1,2,3,4,5]
for x in xs:
    print('x=',x)
    del xs[0]
\end{python}
\end{problem}
\vspace{2in}

\newpage
\begin{problem}
~~~
\begin{python}
xs = [1,2,3,4,5]
for x in list(xs):
    print('x=',x)
    xs.pop()
\end{python}
\end{problem}
\vspace{2in}

\noindent
\textbf{Note:}
Not all containers allow modification in the middle of a loop;
the following code tries to modify a \texttt{deque} and generates an error.
(A \texttt{deque} is a container that supports all of the same operations as python's \texttt{list} type,
but it has different runtime properties,
which we'll talk about next week.)
These error messages are good, and follow the so-called ``fail loudly'' principle.
The inconsistency that some containers fail loudly and some fail silently is one of python's major flaws IMNSHO.

\begin{problem}
~~~
\begin{python}
from collections import deque
xs = deque([1,2,3,4,5])
for x in xs:
    print('x=',x)
    del xs[0]
\end{python}
\end{problem}
\vspace{2in}


\ignore{
\newpage
\begin{problem}
Consider the following two functions:
\begin{python}
def print_container_1(xs):
    for i in range(len(xs)):
        print('xs[i]=',xs[i])

def print_container_2(xs):
    for x in xs:
        print('x=',x)
\end{python}
Notice that both functions will work whether the \texttt{xs} parameter is a list or a deque.
Whenever a function works for more than one type of input, we call it \textbf{polymorphic}.
\begin{enumerate}
    \item 
        Assume we have a \textbf{list} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_1} on this list?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{list} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_2} on this list?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{deque} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_1} on this deque?
        (Use big-O notation.)
        \vspace{1in}
    \item 
        Assume we have a \textbf{deque} with \texttt{n} elements.
        What is the runtime of \texttt{print\_container\_2} on this deque?
        (Use big-O notation.)
        \vspace{1in}
\end{enumerate}
\end{problem}

\newpage
\begin{problem}
Consider the following python function.
\begin{python}
def foo(xs,ys):
    for x in xs:
        for y in ys:
            print('x,y=',x,y)
    for x in xs:
        print('x=',x)
    for y in ys:
        print('y=',y)
\end{python}
Notice that \texttt{foo} is polymorphic in the sense that both \texttt{xs} and \texttt{ys} can be any container type (list, deque, set, dict, etc.).
\begin{enumerate}
    \item 
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{list} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
    \item
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{set} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
\end{enumerate}
\end{problem}

\begin{problem}
Consider the following python function.
\begin{python}
def foo(xs,ys):
    for x in xs:
        if x in ys:
            print('x in ys for x=',x)
\end{python}
Notice that \texttt{foo} is polymorphic in the sense that both \texttt{xs} and \texttt{ys} can be any container type (list, deque, set, dict, etc.).
\begin{enumerate}
    \item 
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{list} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
    \item
        Assume that \texttt{xs} is a \textbf{list} with $n$ elements,
        and that \texttt{ys} is a \textbf{set} with $m$ elements.
        What is the runtime of \texttt{foo}?
        (Use big-O notation.)
        \vspace{1in}
\end{enumerate}
\end{problem}
}
\end{document}
